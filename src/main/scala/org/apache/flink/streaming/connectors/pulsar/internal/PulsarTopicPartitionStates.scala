/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.flink.streaming.connectors.pulsar.internal

import org.apache.flink.streaming.api.functions.{AssignerWithPeriodicWatermarks, AssignerWithPunctuatedWatermarks}
import org.apache.flink.streaming.api.watermark.Watermark
import org.apache.flink.types.Row

import org.apache.pulsar.client.api.MessageId

/**
 * The state that the Flink Pulsar Reader holds for each Pulsar partition.
 *
 * <p>This class describes the most basic state (only the offset), subclasses
 * define more elaborate state, containing current watermarks and timestamp
 * extractors.
 *
 */
class PulsarTopicState(val topic: String) {

  @volatile var offset: MessageId = MessageId.earliest
  @volatile var committedOffset: MessageId = MessageId.earliest

  def isOffsetDefined(): Boolean = offset != MessageId.earliest

  override def toString: String =
    s"$topic offset = ${if (isOffsetDefined()) offset else "not set"}"

}

object PoisonState extends PulsarTopicState("n/a")

/**
 * A special version of the per-pulsar-partition-state that additionally holds
 * a periodic watermark generator (and timestamp extractor) per partition.
 *
 */
class PulsarTopicStateWithPeriodicWatermarks(
    topic: String,
    periodicWatermarks: AssignerWithPeriodicWatermarks[Row])
  extends PulsarTopicState(topic) {

  /** The last watermark timestamp generated by this partition. */
  @volatile var partitionWatermark: Long = Long.MinValue

  def getTimestampForRow(row: Row, timestamp: Long): Long = {
    periodicWatermarks.extractTimestamp(row, timestamp)
  }

  def getCurrentWatermarkTimestamp(): Long = {
    val wm = periodicWatermarks.getCurrentWatermark
    if (wm != null) {
      partitionWatermark = Math.max(partitionWatermark, wm.getTimestamp)
    }
    partitionWatermark
  }

  override def toString: String =
    s"${getClass.getName}: $topic, offset= $offset, watermark= $partitionWatermark"
}

/**
 * A special version of the per-pulsar-partition-state that additionally holds
 * a periodic watermark generator (and timestamp extractor) per partition.
 *
 * <p>This class is not thread safe, but it gives volatile access to the current
 * partition watermark ({@link #getCurrentPartitionWatermark()}).
 *
 */
class PulsarTopicStateWithPunctuatedWatermarks(
    topic: String,
    punctuatedWatermarks: AssignerWithPunctuatedWatermarks[Row])
  extends PulsarTopicState(topic) {

  /** The last watermark timestamp generated by this partition. */
  @volatile var partitionWatermark: Long = Long.MinValue

  def getTimestampForRow(row: Row, pulsarEventTimestamp: Long): Long = {
    punctuatedWatermarks.extractTimestamp(row, pulsarEventTimestamp)
  }

  def checkAndGetNewWatermark(row: Row, timestamp: Long): Watermark = {
    val wm = punctuatedWatermarks.checkAndGetNextWatermark(row, timestamp)
    if (wm != null && wm.getTimestamp > partitionWatermark) {
      partitionWatermark = wm.getTimestamp
      wm
    } else {
      null
    }
  }

  def getCurrentPartitionWatermark: Long = partitionWatermark

  override def toString: String =
    s"${getClass.getName}: $topic, offset= $offset, watermark= $partitionWatermark"
}
